/**
 * Лабораторная работа №3. Перегрузка операторов, константные методы, битовые
 * поля, объединения.
 *
 * В этой работе и далее предполагается, что вы будете использовать классы,
 * написанные в прошлых работах, и дополнять их по необходимости. Эти классы
 * будут называться по имени без дополнительных указаний, что их надо взять из
 * прошлой работы.
 *
 * Предполагается, что новый классы будут созданы по аналогии с предыдущими
 * работами в отдельных файлах, которые будут включены в сборку.
 *
 * При работе с классами - в учебных целях - нельзя пользоваться контейнерами
 * стандартной библиотеки и нужно следовать принципам инкапсуляции.
 */

#include <utility>
#include <cassert>
#include <iostream>
#include "matrix.hpp"
#include "mystring.hpp"
#include "shortarray.hpp"
#include "shortarray2.hpp"
#include "shortarray3.hpp"
#include "workerdb.hpp"
#include "basefile.hpp"
#include "boolarray.hpp"


int main() {

    /**
     * Задание 1. Перегрузка операторов.
     */

    /**
     * Задание 1.1. Оператор присваивания.
     *
     * Перегрузите оператор присваивания для классов `MyString` и `Matrix`.
     * Ожидается, что оператор присваивания работает так же, как конструктор
     * копирования. 
     *
     * Проверьте корректность работы оператора в следующих блоках кода.
     */

    {
            MyString s1("AAA"), s2;
            s2 = s1;
            s1.print(); s2.print();
            s1 = "CCC";
            s2 = MyString("tmp");
            s1.print(); s2.print();
            s1 = s1;

    }

    {
        Matrix m1(10), m2(10, 2);
        m1 = m2;
        m2 = Matrix(3, 4, 1.0);
        m1 = m1;
    }

    /**
     * Задание 1.2. Перегрузка арифметических операторов. Перегрузка методами и
     * глобальными функциями.
     */

    /**
     * Задание 1.2.1. Составное присваивание.
     *
     * Для класса `Matrix` перегрузите следующие операторы методом класса:
     * - `+=` и `-=` с объектом класса `Matrix`;
     * - `*=` и `/=` со значением double.
     *
     * Такие операторы не должны менять правый операнд. При наличии недопустимых
     * аргументов выкиньте какое-нибудь исключение.
     *
     * Ваши операторы должны работать в следующем блоке кода.
     */

    {
        std::cout << "=== 1.2.1 ===" << std::endl;
        Matrix m1(4), m2(4, 4, 1);
        std::cout << "Before +=:" << std::endl;
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                std::cout << m2.get(i, j) << " ";
            }
            std::cout << std::endl;
        }

        m2 += m1;
        std::cout << "After +=:" << std::endl;
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                std::cout << m2.get(i, j) << " ";
            }
            std::cout << std::endl;
        }

        m2 -= m1 += m1;
        std::cout << "After -= +=:" << std::endl;
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                std::cout << m2.get(i, j) << " ";
            }
            std::cout << std::endl;
        }
        std::cout << "And first one:" << std::endl;
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                std::cout << m1.get(i, j) << " ";
            }
            std::cout << std::endl;
        }

        m1 *= 2;
        std::cout << "After *= 2 (first):" << std::endl;
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                std::cout << m1.get(i, j) << " ";
            }
            std::cout << std::endl;
        }

        m2 /= 3;
        std::cout << "After /= 3 (second):" << std::endl;
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                std::cout << m2.get(i, j) << " ";
            }
            std::cout << std::endl;
        }
    }

    /**
     * Задание 1.2.2. Бинарные операторы.
     *
     * Для класса `Matrix` перегрузите следующие операторы методом класса:
     * - `+` и `-` с объектом класса `Matrix`;
     * - `*` с объектом класса `Matrix`;
     * - `*` и `/` со значением double.
     *
     * Эти операторы не должны изменять ни левый, ни правый операнд и возвращать
     * новое значение.
     */

    {
        std::cout << "=== 1.2.2 ===" << std::endl;
        Matrix m1(4), m2(4, 4, 1);
        std::cout << "At the start:\nFirst:" << std::endl;
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                std::cout << m1.get(i, j) << " ";
            }
            std::cout << std::endl;
        }
        std::cout << "Second:" << std::endl;
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                std::cout << m2.get(i, j) << " ";
            }
            std::cout << std::endl;
        }
        Matrix m3 = (m1 + m2) * m1 * 4 / 2 - m2; // If we wish to replace them (like make 2.0*m1, not m1*2.0), we might need friendly function
        std::cout << "Multiplied (third):" << std::endl;
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                std::cout << m3.get(i, j) << " ";
            }
            std::cout << std::endl;
        }
    }

    /**
     * Задание 1.2.3. Перегрузка глобальными функциями.
     *
     * Перегрузите оператор `*` для операндов `double` и `Matrix` глобальной
     * функцией.
     *
     * Перегрузите унарный оператор `-` для класса `Matrix` с помощью глобальной
     * функции.
     *
     * Какую из этих функций нельзя перегрузить методом класса? Почему?
     */
    // cannot overload *. Because on the left may stay not Matrix, but overloaded operators
    // require the first element to be class type.
    // to do this, we need to create a friendly-function

    // Example
    {
        Matrix m(3, 3, 1);
        Matrix m2 = 2 * m;
        Matrix m3 = -m;
    }

    /**
     * Задание 1.2.4. Операторы для строки.
     *
     * Перегрузите операторы `+` и `+=` для класса `MyString`, где в качестве
     * правого операнда будет `MyString` или `const char *`. Сложение в этом 
     * случае должно выполнять конкатенацию строк.
     *
     * Ваши операторы должны работать в следующем блоке кода.
     */

    {
        std::cout << "=== Test 1.2.4 ===" << std::endl;
        MyString s1("abc"), s2("def"), s3;
        s1.print();
        s2.print();
        s3.print();
        s1 += s2 += "111";
        std::cout << std::endl;
        s1.print();
        s2.print();
        s2 += "222" + s1 + "333";
        std::cout << std::endl;
        s1.print();
        s2.print();
        s3 += s3;
        std::cout << std::endl;
        s3.print();
    }

    /**
     * Задание 1.3. Move-семантика.
     *
     * Перегрузите move-оператор присваивания и move-конструктор для классов
     * `MyString` и `Matrix`. В этих операторах нужно "забирать" данные из
     * правого операнда, а не копировать. При этом правый операнд должен
     * становиться "пустым".
     *
     * С помощью отладчика или отладочной печати отследите, сколько раз в
     * следующем блоке происходит выделение динамической памяти, - до реализации
     * move-оператора/конструктора и после.
     */

    {
        MyString s1("abc");
        MyString s2 = s1 + "ccc";     // 1 (temporary during summing)
        s1 = "abc" + s2;              // 1 (temporary during summing)
        s2 = std::move(s1);           // 0

        Matrix m1(4), m2 = m1 + m1;   // 3 (m1, m2, temporary during summing)
        m1 = m2 * m1;                 // 1 (temporary during multiplying)
        m2 = std::move(m1);           // 0
    }

    /**
     * Задание 1.4. Операторы сравнения.
     *
     * Реализуйте для класса `MyString` операторы сравнения `==`, `!=`, `<`,
     * `<=` для сравнения с объектами `MyString` и `const char *`.
     *
     * Операторы должны сравнивать строки лексиграфически.
     */

    {
        MyString s1("abc"), s2("ab"), s3 = s1;
        assert(s2 < s1);
        assert(s1 == s3);
        assert(s1 != s2);
        assert(s1 <= s3);
        assert("ab" == s2);
        assert("aba" < s1);
        assert("aba" <= s3);
    }

    /**
     * Задание 1.5. Оператор индексирования.
     *
     * Перегрузите оператор индексирования для класса `MyString`, который
     * возвращает ссылку на i-тый символ. Если индекс выходит за границы
     * массива, киньте какое-нибудь исключение.
     */

    {
        MyString s1("abc");
        s1[0] = s1[1] = 'd';
    }

    /**
     * Задание 1.6. Операторы ввода и вывода с потоками стандартной библиотеки.
     *
     * Реализуйте для класса `MyString` операторы `<<`, который позволит
     * выводить строку в поток вывода `std::ostream`.
     *
     * Реализуйте для класса `MyString` оператор `>>`, который позволит вводить
     * строку до первого переноса строки из потока ввода `std::istream`.
     *
     * Проверьте работу этих операторов на следующем примере.
     */

    {
        MyString s("123");
        std::cout << "This is my string: '" << s << "'\n";
        std::cout << "Enter your string: ";
        std::cin >> s;
        std::cout << "Your string: '" << s << "'\n";
    }

    /**
     * Задание 2. Константные методы.
     *
     * Объявите все методы (в том числе перегруженные операторы), которые не
     * должны менять объект, для которого они были вызваны, константными.
     *
     * После этого следующая функция должна собираться:
     *
     * MyString addTxtExtension(const MyString &path) { return path + ".txt"; }
     */

    /**
     * Задание 3. Объединения и битовые поля.
     */

    /**
     * Задание 3.1. Динамический массив.
     *
     * Реализуйте класс ShortArray, который будет хранить динамический массив
     * элементов типа short, количество выделенной памяти (size_t) и количество
     * элементов массива (size_t).
     *
     * Реализуйте для этого класса конструкторы и операторы, которые посчитаете
     * нужными, оператор `[]`, а также методы:
     * - `void push(short new_val)` - для добавления элемента в конец массива;
     * - `short pop()` - для удаления и возвращения элемента из конца массива;
     * - `size_t size() const` - возвращает размер массива;
     * - `void resize(size_t new_size, short fill_value = 0)` - изменение
     *    размера массива, при увеличении размера массив заполняется значением
     *    `fill_value`.
     * 
     * Продемонстрируйте ниже работу класса.
     */

    {
        ShortArray arr(3, 10); // [10, 10, 10]
        std::cout << "Initial array: " << arr << "\n";

        arr.push(42); // [10, 10, 10, 42]
        arr.push(99); // [10, 10, 10, 42, 99]
        std::cout << "After push: " << arr << "\n";

        arr.resize(7, 5); // [10, 10, 10, 42, 99, 5, 5]
        std::cout << "After resize: " << arr << "\n";

        std::cout << "Popped value: " << arr.pop() << "\n"; // 5
        std::cout << "After pop: " << arr << "\n";

        std::cout << "Element at index 2: " << arr[2] << "\n"; // 10

        const ShortArray arr2 = arr;
        std::cout << "Const array: " << arr2 << "\n";
        std::cout << "Const element: " << arr2[1] << "\n";
    }

    /**
     * Задание 3.2. Объединения.
     *
     * Есть проблема: даже для самого маленького массива будет
     * выделена динамическая память. Однако, размер у такой структуры может
     * быть, например, 24 байта, что вмещает встроенный массив из 12 элементов.
     *
     * С помощью объединений в языке С мы можем интерпретировать одни и те же
     * данные по разному. Поля динамического массива { short *, size_t, size_t }
     * мы можем воспринимать как массив short.
     *
     * Используя объединения, реализуйте хранение элементов массива прямо в
     * памяти, отведенной под этот класс, если массив туда помещается.
     * По каким признаком вы можете различить хранится ли память динамически или
     * она встроена в класс?
     *
     * Рассчитайте допустимый размер массива через оператор sizeof. Проверьте,
     * что объем памяти, занимаемой классом не увеличилась.
     *
     * Продемонстрируйте, что все методы работают верно для обоих способов
     * хранения памяти.
     */

    {
        std::cout << "Size of old ShortArray: " << sizeof(ShortArray) << " bytes\n";
        std::cout << "Size of new ShortArray-like struct: " << sizeof(ShortArray2) << " bytes\n";

        ShortArray2 arr(3, 10); // [10, 10, 10]
        std::cout << "Initial array: " << arr << "\n";

        for (int i = 0; i < 10; ++i) {
            arr.push(i);
            for (int j = 0; j < arr.size(); ++j) {
                std::cout << arr[j] << " ";
            }
            std::cout << "\n====\n";
        }

        std::cout << "After big push: " << arr << "\n";

        while (arr.size() > 0) {
            std::cout << "pop -> " << arr.pop() << "\n";
        }
    }

    /**
     * Задание 3.3. Выравнивание и битовые поля.
     *
     * Для того, чтобы различить, используется ли динамическая память, можно
     * использовать последний бит адреса динамически выделенного массива. Из-за
     * того, что используется тип short, этот адрес всегда будет делиться на 2
     * из-за выравнивания адресов. Таким образом, если самый младший бит будет
     * равен 1, то мы можем быть уверены, что динамическая память не
     * используется.
     *
     * С помощью битовых полей получите доступ к этому биту, а остальную часть
     * байта, в котором он находится, интерпретируйте как размер массива.
     *
     * Добейтесь, чтобы ваш класс работал, как в пункте 3.2, при этом его размер
     * был бы равен `sizeof(short *) + 2 * sizeof(size_t)`.
     */
    
    {
        std::cout << "Size of ShortArray3: " << sizeof(ShortArray3) << std::endl;
        std::cout << "=== Тест 1: Конструктор по умолчанию ===\n";
        ShortArray3 arr1;
        print_status(arr1);

        std::cout << "=== Тест 2: Конструктор с размером ===\n";
        ShortArray3 arr2(5, 42);
        print_status(arr2);

        std::cout << "=== Тест 3: Индексация ===\n";
        for (size_t i = 0; i < arr2.size(); ++i) {
            arr2[i] *= 2;
        }
        print_status(arr2);

        std::cout << "=== Тест 4: Push ===\n";
        for (int i = 0; i < 5; ++i) {
            arr2.push(i * 10);
        }
        print_status(arr2);

        std::cout << "=== Тест 5: Pop ===\n";
        for (int i = 0; i < 3; ++i) {
            std::cout << "Popped value: " << arr2.pop() << "\n";
        }
        print_status(arr2);

        std::cout << "=== Тест 6: Resize ===\n";
        arr2.resize(15, -1);
        print_status(arr2);

        std::cout << "=== Тест 7: Копирующий конструктор ===\n";
        ShortArray3 arr3 = arr2;
        print_status(arr3);

        std::cout << "=== Тест 8: Оператор присваивания ===\n";
        ShortArray3 arr4;
        arr4 = arr2;
        print_status(arr4);

        std::cout << "=== Тест 9: Перемещающий конструктор ===\n";
        ShortArray3 arr5 = std::move(arr4);
        print_status(arr5);

        std::cout << "=== Тест 10: Перемещающее присваивание ===\n";
        ShortArray3 arr6;
        arr6 = std::move(arr5);
        print_status(arr6);
    }

    /**
     * Задание 4. Ассоциативный массив. Итератор. Операторы инкремента.
     */

    /**
     * Задание 4.1. Ассоциативный массив.
     *
     * Создайте класс `WorkerDb`, который будет хранить базу данных рабочих
     * некой организации в виде ассоциативного массива. В таком массиве индексом
     * является не номер элемента, а какое-то другое значение. В этом случае -
     * фамилия сотрудника. В самом же массиве будет храниться структура с
     * информацией о работнике.
     *
     * Реализуйте для этого класса оператор `[]`, который будет по фамилии
     * возвращать ссылку на данные работника. Если такого работника еще нет,
     * то запись для этого работника создается.
     *
     * Используйте для хранения строковых данных ваш класс MyString.
     */

    {
        WorkerDb db;
        db["Ivanov"] = WorkerData("Ivan", 34);
        db["Petrov"] = WorkerData("Petr", 43);
        std::cout << "Ivanov's name = " << db["Ivanov"].name_ << "\n";
        std::cout << "Petrov's age = " << db["Petrov"].age_ << "\n";
    }

    /**
     * Задание 4.2. Итератор.
     *
     * На практике воспользоваться таким классом будет довольно сложно, потому
     * что чтобы получить информацию о работниках, нужно откуда-то знать их
     * фамилии (ключи в массиве).
     *
     * Чтобы решить такую проблему, часто используют паттерн *итератор*.
     * Объект-контейнер (у нас - WorkerDb) умеет возвращать объект, который
     * перебирает его элементы. Для обычного массива в С таким объектом является
     * указатель, однако, сам по себе указатель не содержит информации, когда
     * элементы массива закончатся. Поэтому в пару к указателю, который
     * указывает на элементы (`begin`), добавляют указатель, который будет
     * обозначать, что элементы закончены (`end`):
     *
     * ```
     * int arr[] = {1, 2, 3, 4, 5};
     *
     * for (int *begin = arr, *end = arr + sizeof(arr) / sizeof(arr[0]);
     *      begin != end;
     *      ++begin)
     *  {
     *      std::cout << *begin << ' ';
     *  }
     *
     * ```
     *
     * В языке C++ наследуется эта идиома: объекты-контейнеры возвращают
     * объект-итератор методами `begin()` и `end()`. Для итератора определены
     * операторы `==`, `!=`, префиксный и постфиксный `++`, а также операторы
     * разыменования `*` и `->`. Также часто итераторы копируются (оператор
     * `=`).
     *
     * Реализуйте для вашего класса `WorkerDb` итератор, который при
     * разыменовании будет возвращать ссылку на `WorkerData`, а также иметь
     * метод `key()`, который будет возвращать ключ для этих данных
     * (фамилию). Итераторы допускается объявлять дружественными для
     * класса-контейнера.
     *
     * Проверьте ниже работу итератора.
     */

    {
        WorkerDb db;
        db["Ivanov"] = WorkerData("Ivan", 34);
        db["Petrov"] = WorkerData("Petr", 43);
        for (auto it = db.begin(); it != db.end(); ++it)
        {
            std::cout << it.key() << " -> " << it->name_ << '\n';
        }
    }

    /**
     * Задание 4.3. Работа "прикладного программиста".
     *
     * Не меняя класс `WorkerDb`, напишите функцию `print_db(WorkerDb&)`,
     * которая будет печатать базу данных работников на консоль, и функцию
     * `double get_avg_age(WorkerDb&)`, которая будет подсчитывать средний
     * возраст сотрудников. Эти функции не должны быть дружественными классу
     * `WorkerDb`.
     */

    {
        WorkerDb db;

        db["Ivanov"] = WorkerData(MyString("Ivan"), 34);
        db["Petrov"] = WorkerData(MyString("Petr"), 43);
        db["Amogus"] = WorkerData(MyString("Abobus"), 28);

        std::cout << "=== Staff Database ===\n";
        print_db(db);

        double avg_age = get_avg_age(db);
        std::cout << "Average age: " << avg_age << "\n";
    }

    /**
     * Задание 5. Неявно определенные операторы. Удаление операторов.
     *
     * Проверьте, определен ли оператор присваивания для класса `BaseFile` из
     * работы 2? Что он делает? Имеется ли смысл в таком операторе?
     *
     * Явно удалите оператор присваивания и конструктор копирования ключевым
     * словом `delete`, но определите их move-аналоги в этом классе.
     * Продемонстрируйте их работу.
     */

    {
        FILE* fp = fopen("test.txt", "w+");
        BaseFile src(fp, "r+");
        BaseFile dst;

        dst = std::move(src);

        char buffer[100] = "Hello, World!";
        std::cout<< "Wrote " << dst.write(buffer, strlen(buffer)) << " bytes." << std::endl;
        dst.seek(0);

        char readBuffer[100];
        size_t bytesRead = dst.read(readBuffer, sizeof(readBuffer));
        readBuffer[bytesRead] = '\0';
        std::cout << "Read from file: " << readBuffer << std::endl;
    }

    /**
     * Задание 6. Оператор неявного приведения типа.
     *
     * Реализуйте класс `BoolArray`, представляющий динамический массив
     * логических значений (тип bool). В наивной реализации (`new bool[n]`) есть
     * проблема: каждая переменная типа bool занимает 1 байт, то есть 8 бит, в
     * то время как она могла бы занимать 1 бит.
     *
     * Реализуйте этот класс таким образом, чтобы каждое значение значений
     * действительно занимало 1 бит (точнее сказать, чтобы n значений занимали
     * не более ceil(n / 8), где ceil - целая часть числа с округлением вверх).
     *
     * Класс должен поддерживать следующее поведение:
     */

    {
        /// Создается массив из 10 значений false
        BoolArray ar1(10);

        /// Создается массив из 5 значений true
        BoolArray ar2(5, true);

        /// Создается независимая копия `ar2`
        BoolArray ar3(ar2);

        /// 4 и 6 элементу (нумерация с 0) устанавливаются заданное значение
        ar1[4] = ar1[6] = true;

        /// Над полученными значениями выполняем логические операции
        ar1[2] = (!ar1[6] && ar1[8] || (ar1[0] != true));

        /// Выведем массив на печать
        std::cout << "[";
        for (int i = 0; i < ar1.size(); ++i) {
            if (i > 0) std::cout << ", ";
            std::cout << ar1[i];
        }
        std::cout << "]\n";

        /// Выведем массив на печать по-другому
        std::cout << "[";
        for (int i = 0, printed = 0; i < ar1.size(); ++i) {
            if (ar1[i]) {
                if (printed++ > 0) std::cout << ", ";
                std::cout << i;
            }
        }
        std::cout << "]\n";


       /// Метод `resize` изменяет размер массива. Если новый размер больше, то
       /// новые значения дополняются заданным значением (по умолчанию false). Если
       /// новый размер меньше, то конец массива отбрасывается.

        ar1.resize(12, true);
        /// выведите массив на печать

        std::cout << "After resize to 12: " << ar1 << "\n";

        ar1.resize(4, true);
        /// выведите массив на печать снова

        std::cout << "After resize to 4: " << ar1 << "\n";

    }

	return 0;
}
